{
  "memoirs": [
    {
      "level": 1,
      "title": "Project Memoirs: The Beginning",
      "icon": "📝",
      "content": "<h2>Project Start</h2><p>I started the project in July 2025. I had just finished a contract with Aeroflot, where I developed the mobile version of the flight booking service. Sitting by the river with my MacBook, I thought about the next step in my career.</p><p>It was obvious that I needed to look for a new job or a new project. But the market was overheated, interviews felt pointless — dozens of applicants, the same templates, memory tests. I wanted something different — for offers to find me, not the other way around.</p><h2>The Online Resume Concept</h2><p>That’s how the idea was born: create an interactive online resume in the form of a game. It would be a gamified form of self‑presentation where an employer plays the game and gets to know me — not only as a developer but also as a person.</p><p>Through levels, XP, achievements, and philosophical questions, the game acts as a filter. The answers reveal values and help avoid mismatches even before contact. To reach me, you need to progress to a certain stage.</p><h2>Help from AI</h2><p>By that time, I was already actively using AI in my work. I decided the entire project would be generated by AI while I acted as architect and manager. Everything — documentation, structure, code — was created with its help.</p><p>The technologies were chosen intuitively: <strong>D3.js</strong> for graphics, <strong>Vue.js</strong> for the frontend, <strong>Node.js + Express + SQLite</strong> for the backend. I built the first demo in a few days — the idea worked.</p><h2>Removing the Backend</h2><p>Over time I realized the backend was unnecessary. Maintaining typing and synchronization between server and client was tiring and unjustified. I removed the backend and moved everything to the frontend.</p><p>So began the refactor. I discovered lots of coupling, a chaotic structure, repetition, violations of architectural principles. It was painful, but everything had to be redone.</p><h2>Architectural Refactoring</h2><p>I completely reworked the project architecture: separated responsibilities, cleaned up types, optimized the file structure. Everything became transparent and convenient. Patterns were introduced: factories, layers, sources of truth, singletons, etc. Some — intuitively, without names.</p><p>I also abandoned unit tests. They slowed down development and added complexity. For this project it was excessive. Now I’m sure testing is not always a good thing.</p><h2>New Phase</h2><p>The project is now in its final stage. Thanks to the new architecture, adding features became fast and enjoyable. I brought AI back — but now on prepared soil. Everything became logical, scalable, and transparent.</p><p>The project isn’t finished yet, but it will be. It’s my way to tell my story, show myself in action, and meet those who truly want to work with me. To be continued.</p>"
    },
    {
      "level": 2,
      "title": "Project Memoirs: Vision",
      "icon": "📓",
      "content": "<h2>New architecture: project maturity</h2><p>After finishing the first version, the second phase began — a deep architectural refactor. It was decided the project had outgrown a pet‑project and needed a <strong>serious, scalable architecture</strong> suitable for a professional environment. The main goal was to achieve modularity, clarity, and extensibility.</p><h3>Introducing Architectural Principles</h3><ul><li><strong>Clean Architecture</strong> — separated business logic from UI, created independent layers: Domain, Application, Infrastructure.</li><li><strong>Domain‑Driven Design (DDD)</strong> — the code is organized around domains: achievements, bonuses, canvas, game. Each domain is now isolated.</li><li><strong>Use Case Pattern</strong> — each operation is a separate use case: <code>UnlockAchievementUseCase</code>, <code>OpenBonusModalUseCase</code>, <code>CanvasUseCase</code>, etc.</li><li><strong>Repository Pattern</strong> — access to data and side effects is encapsulated in repositories: <code>EffectsRepository</code>, <code>CanvasRepository</code>, <code>BubbleManagerRepository</code>.</li><li><strong>Factory Pattern</strong> — factories create and configure use cases, providing centralized dependency management.</li><li><strong>Container/Presentational Pattern</strong> — logic and UI are separated: containers manage state, presentational components only render data.</li></ul><h3>Results and Benefits</h3><p>The project became easier to maintain: each part is responsible for its own concerns, components are reusable, logic is isolated. Everything became <strong>readable, testable, and scalable</strong>. This code can be shipped to production and withstand growth and changes. The architecture allows new features to be added easily — e.g., modal queue, shake effects, achievements — all built on the same principles.</p><h3>Further Development</h3><p>The next task is to bring all parts of the project to a unified architectural standard. This includes migrating old composables to a use‑case style, extracting new domains, improving interaction with the UI, and finalizing the modal and effects system. The project has become not just a self‑presentation, but an <strong>architectural demonstration of a mature frontend developer</strong>.</p>"
    },
    {
      "level": 3,
      "title": "Project Memoirs: Interaction",
      "icon": "🎮",
      "content": "<h2>UX as game design</h2><p>After the architectural framework was completed, I focused on the most interesting and sensory part of the project — <strong>interaction</strong>. If earlier the focus was on <em>what the project does</em>, now it was important <em>how it does it</em>.</p><p>I began to think about how the player feels progress, how the interface responds to events, how alive and responsive the system seems. Every click, every bubble should evoke emotion. It was no longer just UI — it became <strong>game design</strong>.</p><h2>Modal queue and effects</h2><p>I implemented a modal management system via a prioritized queue. Now modals don’t overlap but appear sequentially, with pauses and fade animations. This simple change made the interface feel natural and consistent.</p><p>Then came a <strong>shake effects system</strong>: when receiving a bonus or leveling up, the UI begins to “shake” — lives panel, XP, achievements. All of this is based on components subscribing to the <code>ShakeEffectStore</code>, with minimal DOM interference and a clear architecture.</p><h2>Micro‑animations and micro‑delights</h2><p>I implemented particle bursts, shards, soft blinking, and subtle text motion. These “micro‑delights” don’t affect logic but make the experience pleasant and rich. They don’t just decorate — they provide <strong>physical feedback</strong>.</p><p>Debounces, delays, sequences were also introduced. Animation became part of the business logic: we wait for it to finish before launching the next modal or event. Everything is synchronized — the UX became cinematic.</p><h2>Performance system</h2><p>One of the most interesting technical challenges was an <strong>adaptive performance system</strong>. I created a composer that monitors FPS and automatically adjusts the number of visual elements — primarily the starfield background. When FPS drops, the system smoothly reduces nodes while retaining visual appeal and lowering GPU load.</p><p>This solution made the project stable on different devices — from powerful desktops to low‑end mobiles. The composer became an example of how technical necessity can be elegantly integrated into the architecture without violating clean‑code principles.</p><h2>Interface as storytelling</h2><p>The game metaphor allowed approaching the interface as a <strong>storytelling tool</strong>. Even technical things — XP, levels, bubbles — became part of the narrative. The user doesn’t just click — they <em>live</em> the journey. This was my key discovery: UI is not a form, it is <em>direction</em>.</p><p>The project increasingly turned into a living creature. Every change triggered a response, and I felt as if I were working not on code, but on an <strong>interactive piece</strong>.</p>"
    },
    {
      "level": 4,
      "title": "Project Memoirs: Growth",
      "icon": "🌱",
      "content": "<h2>A turn in the journey</h2><p>What was intended as a week‑long sprint turned into a two‑month expedition. The initial plan — “do it over a weekend” — grew layers, branches, and ideas. Every morning brought a new wish, every night — a refactor. The project began to live its own life.</p><p>And this turned out to be more valuable than any quick result. I gained unprecedented experience — not in writing features, but in <strong>accompanying a living project</strong> where there’s no clear middle. There is only a beginning and — in the future — an end. Everything else is an endless cycle of iterations, impulses, returns, and insights.</p><h2>The game concept under a microscope</h2><p>The idea of an interactive resume in the form of a game also transformed. At first, I wanted to show the entire evolution: 2000, 2005, 2010... But who today cares what I knew in 2008? Even I got bored clicking on bubbles of the past. It was a retrospective without meaning.</p><p>So I reduced the historical part to two levels — just to show that the path existed. And starting from level three, I kept <strong>only the current technologies</strong> — those that are actually used to build this site. This is the <em>true essence</em> — to show what I master now, and what is required to make such a thing.</p><h2>For those who want to build similar things</h2><p>Now the project is not only a resume, but also a kind of <strong>roadmap</strong> for others. Want to create an interactive game about yourself? Look at which technologies are needed, which architectural approaches are applied, and what rakes lie around the corner.</p><p>I believe this approach can inspire developers — not to blindly repeat, but to create their own, unique. The game became a way to pass on experience.</p><h2>Architecture as a catalyst</h2><p>One of the key changes was the introduction of architectural principles: <strong>Clean Architecture</strong>, <strong>Domain‑Driven Design</strong>, <strong>Feature‑Sliced Design</strong>, as well as the good old <code>KISS</code>, <code>DRY</code>, and <code>SOLID</code>. The whole system was rethought, divided into domains, use cases, repositories, and adapters. It became more complex… but cleaner.</p><p>Each part now has its place. New features are implemented quickly. And most surprisingly — the <strong>AI agent</strong> handles such an architecture perfectly. I am not just writing code — I am building an <em>environment for generation</em>.</p><h2>The finale is close</h2><p>This memoir is the penultimate one. I hope. The last one will be about the finish. About how the project will be deployed, receive its domain, and become <strong>available to the world</strong>. For now — we continue the game.</p>"
    }
  ]
}
